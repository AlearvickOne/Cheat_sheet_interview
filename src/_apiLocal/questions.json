{
  "html": [
    {
      "title": "Какой тег используется для создания ссылки?",
      "text": "Для сознания ссылки используется тег <a>"
    },
    {
      "title": "Какой тег используется для вставки изображения?",
      "text": "Для сознания ссылки используется тег <img>"
    },
    {
      "title": "Какой тег находится в <html> определяет заголовок документа?",
      "text": "Заголовок документа определяется с помощью тега <title>"
    },
    {
      "title": "Какой атрибут используется для определения альтернативного текста изображения?",
      "text": "Для альтернативного текса изображения используется атрибут - alt"
    },
    {
      "title": "Какой атрибут позволяет открыть ссылку в новой вкладке?",
      "text": "Для открытия новой вкладки используется атрибут - target=_blank"
    },
    {
      "title": "Что такое метатеги",
      "text": "Metaтеги — это специальные HTML-теги, предназначенные для предоставления структурированных метаданных о веб-странице. Они размещаются в заголовке (тег <head>) HTML-документа и содержат информацию о документе, ключевые слова, краткое описание и другие данные. Metaтеги используются для автоматической обработки веб-страницами и браузерами, а также поисковыми роботами."
    },
    {
      "title": "Для чего используется атрибут 'placeholder'?",
      "text": "Атрибут 'placeholder' используется для отображения текстовой подсказки или примера ввода в поле формы до того, как пользователь начнет вводить свои данные."
    },
    {
      "title": "Как создать непронумерованный список в HTML?",
      "text": "Для создания такого списка в HTML используется тег <code>ul</code>, а для определения каждого пункта списка - тег <code>li</code>."
    },
    {
      "title": "Что такое HTML?",
      "text": "HTML (HyperText Markup Language) - это стандартизированный язык разметки, который используется для создания и разработки веб-страниц. Это система для разметки отдельных частей веб-страницы с использованием тегов, заключенных в угловые скобки."
    },
    {
      "title": "Что делает тег <!DOCTYPE>?",
      "text": "`Это декларация, которая информирует веб-браузер о версии языка разметки, использованной при создании веб-страницы. Это помогает браузеру корректно отобразить страницу."
    },
    {
      "title": "Какой тег используется для создания таблицы?",
      "text": "Для создания таблицы в html используется тег <table>"
    },
    {
      "title": "Какой тег используется для создания заголовка таблицы?",

      "text": "Для создания заголовка таблицы используется тег <thead>"
    },
    {
      "title": "Какой тег используется для создания строки таблицы?",
      "text": "Для создания строки таблицы используется тег <tr>"
    },
    {
      "title": "Какой тег используется для создания ячейки таблицы?",
      "text": "Для создания ячейки таблицы используется тег <td>"
    },
    {
      "title": "Что такое семантические теги в HTML?",
      "text": "Семантические теги в HTML - это теги, которые передают информацию о смысле или назначении содержимого, а не только о его внешнем виде. Примеры семантических тегов: header, footer, article, section, nav и др. Они помогают создавать более структурированные и доступные веб-страницы."
    },
    {
      "title": "Какой атрибут используется для установки фонового изображения?",
      "text": "Для установки фонового изображения используется атрибут - background-image"
    },
    {
      "title": "Какой тег используется для создания выпадающего списка?",
      "text": "Для создания выпадающего списка используется тег <select>"
    },
    {
      "title": "Какой тег используется для вставки JavaScript кода в HTML документ?",
      "text": "Для вставки JS кода используется тег <script>"
    },
    {
      "title": "Какой атрибут используется для указания пути к изображению?",
      "text": "Для создания пути к изображению используется атрибут - src"
    },
    {
      "title": "Что делает атрибут 'readonly' в элементе формы?",
      "text": "Атрибут 'readonly' делает элемент формы только для чтения, что значит, что пользователь не может изменять значение элемента, но может просматривать его. Это может быть полезно, если вы хотите отобразить информацию, которая не должна быть изменена."
    },
    {
      "title": "Что такое веб-стандарты и зачем они нужны?",
      "text": "Веб-стандарты - это рекомендации, разработанные группами стандартов, такими как W3C или WHATWG, для обеспечения совместимости и устойчивости веб-технологий. Они включают рекомендации по HTML, CSS, JavaScript и другим веб-технологиям. Соблюдение веб-стандартов помогает обеспечить корректную работу веб-страниц в различных браузерах и устройствах, а также облегчить обслуживание и расширение веб-сайтов в будущем."
    },
    {
      "title": "Что такое отзывчивый (responsive) веб-дизайн?",
      "text": "Это подход к веб-дизайну, который позволяет веб-страницам корректно отображаться и функционировать на различных устройствах, включая мобильные телефоны, планшеты и настольные компьютеры, путем использования гибких макетов, гибких изображений и CSS медиазапросов для адаптации дизайна к различным размерам экрана и характеристикам устройств."
    },
    {
      "title": "Какой тег HTML используется для вставки видео?",
      "text": "Для вставки видео используется тег <video>"
    },
    {
      "title": "Какой тег используется для создания главного заголовка на веб-странице?",
      "text": "Для создания главного заголовка используется тег <h1>"
    },
    {
      "title": "Что делает тег <br>?",
      "text": "Он спользуется для переноса строки, что позволяет создать новую строку в том месте, где он размещен. Это удобный способ управления расположением текста на веб-странице без использования дополнительных стилей или элементов."
    },
    {
      "title": "Какой тег используется для создания упорядоченного списка?",
      "text": "Для создания упорядоченного списка используется тег <ol>"
    },
    {
      "title": "Что такое DOM в контексте веб-разработки?",
      "text": "DOM (Document Object Model) - это программный интерфейс для веб-документов. Это представление структурированного документа в виде объектной модели, которое позволяет программам и скриптам взаимодействовать с содержимым, структурой и стилями веб-страницы. DOM представляет документ как дерево объектов, каждый из которых соответствует части страницы."
    },
    {
      "title": "Какой атрибут используется для определения стилей элемента на странице?",
      "text": "Для определение стилей используется атрибут - style"
    },
    {
      "title": "Что такое атрибут 'alt' в теге <img>?",
      "text": "Он используется для предоставления альтернативного текста, который будет отображаться в случае, если изображение не может быть загружено. Это также может быть полезно для обеспечения доступности, поскольку скрин-ридеры могут использовать этот текст для описания изображения пользователям с ограниченными возможностями."
    }
  ],
  "css": [
    {
      "title": "В чем разница между «сбросом» и «нормализацией» CSS? Что бы вы выбрали и почему?",
      "text": "Сброс (reset) сбрасывает все встроенные в браузер стили элементов. Normalize приводит стили к единому виду во всех браузерах. Лучше использовать Normalize из-за кроссбраузерности."
    },
    {
      "title": "Что такое специфичность селекторов CSS и как она работает?",
      "text": "Специфичность селектора (еще называют весом) это свойство определяющее приоритет стилевого правила, то есть то, какой стиль будет применен к HTML элементу в итоге. Например, используя какую-нибудь UI библиотеку, элементам этой библиотеки будут применены правила заданные авторами по умолчанию. При необходимости можно поменять стили на свои, «перебив» дефолтные более специфичным селектором."
    },
    {
      "title": "Что такое CSS?",
      "text": "CSS (Cascading Style Sheets) - это язык стилей, используемый для описания внешнего вида и форматирования документа, написанного на языке разметки, таком как HTML. CSS позволяет разработчикам управлять макетом, шрифтами, цветами и другими стилистическими аспектами веб-страницы."
    },
    {
      "title": "Почему, как правило, лучше разместить подключение CSS в <head>, а <script> перед тэгом </body>? Знаете ли вы какие-либо исключения, приведите примеры?",
      "text": "Стили рекомендуется подключать в head для того, чтобы страница как можно быстрее приняла свой внешний вид. Скрипты подключенные в head могут затормозить этот процесс, в связи с этим их рекомендуется подключать перед закрывающим тегом body. Исключением являются скрипты аналитики, для определения количества посетителей, которые не дождались загрузки страницы. В этом случае скрипт должен быть подключен в head."
    },
    {
      "title": "Что делает свойство 'z-index' в CSS?",
      "text": "Свойство 'z-index' в CSS контролирует стековый порядок элементов по оси Z. Элемент с большим значением 'z-index' будет отображаться поверх элемента с меньшим значением 'z-index'."
    },
    {
      "title": "Какие есть способы отцентровать div?",
      "text": "Существует несколько способов отцентровать div в CSS, вот некоторые из них: \n1. Использование свойств margin и auto: `margin: 0 auto;`.\n2. Использование Flexbox: `display: flex; justify-content: center; align-items: center;`.\n3. Использование Grid Layout: `display: grid; place-items: center;`.\n4. Использование свойств text-align и inline-block: `text-align: center;` на родительском элементе и `display: inline-block;` на самом div.`."
    },
    {
      "title": "Какое свойство используется для установки цвета фона?",
      "text": "Для установки цвета фона используется свойство - background-color"
    },
    {
      "title": "Какое свойство позволяет установить внешние отступы элемента?",
      "text": "Для установки внешних отсупов элемента используется свойство - margin"
    },
    {
      "title": "Какое свойство используется для установки шрифта?",
      "text": "Для установки шрифта используется свойство - font-family"
    },
    {
      "title": "Какое свойство CSS позволяет контролировать видимость элемента в DOM, но при этом сохраняет его место?",
      "text": "Для контроля видимости элемента используется свойство - visibility: hidden"
    },
    {
      "title": "Какое свойство CSS используется для установки теней элементов?",
      "text": "Для установки теней элементов используется свойство - box-shadow"
    },
    {
      "title": "Какой селектор выбирает все элементы .child, которые являются непосредственными дочерними элементами .parent?",
      "text": "Для этого используется селектор - .parent > .child"
    },
    {
      "title": "Какой селектор CSS выбирает все элементы, которые имеют указанный атрибут, начинающийся с определенной строки?",
      "text": "Для выбора всех элементов с необходимым атрибутом, начинающимся с определенной строки используется селектор - [attr^=value]"
    },
    {
      "title": "Какой селектор CSS выбирает все элементы, которые имеют указанный атрибут, заканчивающийся определенной строкой?",
      "text": "Для выбора всех элементов с необходимым атрибутом, заканчивающимся определенной строкой используется селектор - [attr$=value]"
    }
  ],
  "js": [
    {
      "title": "Как создать файл cookie в js",
      "text": "Используя document.cookie = “message” или используя библиотеку js-cookie."
    },
    {
      "title": "Что такое cookie",
      "text": "Cookie — это небольшие текстовые файлы, которые хранят в себе определенную информацию для браузера о посещенных сайтах. Термин появился благодаря Лу Монтуллу, который вдохновился «magic cookies», представляющими собой объем данных, передаваемых одной программой другой."
    },
    {
      "title": "Что такое примитивные типы данных в js",
      "text": "Это типы, которым может присвоиться не более одного значения. Это number, string,  Boolean, null, undefined, symbol, bigint. Object не является примитивным."
    },
    {
      "title": "Что такое замыкание",
      "text": "Замыкание – это создание функции в качестве дочернего компонента другой функции для запоминания информации родительской функции и взаимодействия с данной информацией в дочерней функции, даже после того, как родительская функция завершила свою работу."
    },
    {
      "title": "Event bubbling (Всплытие событий)",
      "text": "Всплытие событий, или Event Bubbling, это процесс, в котором событие, произошедшее на каком-либо вложенном элементе, всплывает вверх по DOM-дереву и вызывает такие же события на всех родительских элементах. Например, при нажатии на кнопку обработаются сначала ближайшие элементы, потом обработчик будет подниматься все выше по DOM дереву"
    },
    {
      "title": "Event capturing (Перехват событий)",
      "text": "Перехват событий работает наоборот, и события начинают передаваться вниз по уровню. Например, при нажатии кнопки, с функцией handleClick происходит сначала её обработка. Зачем уже от этой кнопки событие передается ближайшим элементам."
    },
    {
      "title": "Event delegation ",
      "text": "Event delegation — это паттерн обработки событий в JavaScript, основанный на механизме всплывания событий (event bubbling). Он заключается в управлении событием на родительском элементе вместо непосредственного обработчика события на элементе, где оно было инициировано."
    },
    {
      "title": "Event Listener ",
      "text": "Event listener — это интерфейс в JavaScript, который позволяет обрабатывать взаимодействие пользователя с приложением. Например, когда пользователь нажимает кнопку. Event listener вызывает определённую функцию при возникновении события. Для добавления event listener используется метод addEventListener(), который принимает три параметра: событие, функция для вызова при возникновении события и необязательный параметр для определения порядка обработки событий в вложенных элементах (true — обработка родительских элементов, false — обработка дочерних элементов)."
    },
    {
      "title": " В чем разница между методами event.preventDefault() и event.stopPropagation()?",
      "text": "Метод event.preventDefault() отключает поведение элемента по умолчанию. Если использовать этот метод в элементе form, то он предотвратит отправку формы (submit). Если использовать его в contextmenu, то контекстное меню будет отключено (данный метод часто используется в keydown для переопределения клавиатуры, например, при создании музыкального/видео плеера или текстового редактора — прим. пер.). Метод event.stopPropagation() отключает распространение события (его всплытие или погружение)."
    },
    {
      "title": "Как узнать об использовании метода event.preventDefault()? ",
      "text": "Для этого мы можем использовать свойство event.defaulPrevented, возвращающее логическое значение, служащее индикатором применения к элементу метода event.preventDefault."
    },
    {
      "title": "Что такое распространение события (Event Propagation)",
      "text": "Когда какое-либо событие происходит в элементе DOM, оно на самом деле происходит не только в нем. Событие «распространяется» от объекта Window до вызвавшего его элемента (event.target). При этом событие последовательно пронизывает (затрагивает) всех предков целевого элемента. Распространение события имеет три стадии или фазы: Фаза погружения (захвата, перехвата) — событие возникает в объекте Window и опускается до цели события через всех ее предков. Целевая фаза — это когда событие достигает целевого элемента. Фаза всплытия — событие поднимается от event.target, последовательно проходит через всех его предков и достигает объекта Window. "
    },
    {
      "title": "Как обработать ошибки",
      "text": "Обработать ошибки можно  с помощью try - catch  и throw new error(‘’)"
    },
    {
      "title": "Что такое Callback функция",
      "text": "Callback-функция (функция обратного вызова) — это передача исполняемого кода в качестве одного из параметров другому коду. Она позволяет выполнять код, заданный в аргументах при вызове функции, который может быть недоступен для прямого вызова из этой функции. Callback-функции часто используются в алгоритмах, где нужно вычислить хеш-значение от строки, или для обработки определённых сигналов."
    },
    {
      "title": "Как работают таймеры в js",
      "text": "Таймеры в JavaScript работают с помощью двух основных функций: setTimeout и setInterval. Функция setTimeout используется для однократного выполнения действия через определённый промежуток времени, а setInterval — для постоянного выполнения действия через заданные интервалы. Функция setTimeout принимает два аргумента: функцию, которая должна выполниться, и время в миллисекундах до выполнения. Функция clearTimeout используется для остановки таймера. Функция setInterval работает аналогично, но вызывает переданную функцию через заданные интервалы времени. Для остановки таймера используется clearInterval."
    },
    {
      "title": "Как проверить. Является ли значение массивом?",
      "text": "Можно проверить с помощью метода Array.isArray()"
    },
    {
      "title": "Отличие undefined от null",
      "text": "undefined указывает на отсутствие значения у переменной, но она была объявлена. null означает явное указание на отсутствие значения у переменной."
    },
    {
      "title": "В чем разница между ‘var’, ‘let’ и ‘const’",
      "text": "Var – имеет функциональную область видимости. Let – имеет блочную область видимости. Const – константа так-же имеет блочную область видимости, но её нельзя изменять, если она является примитивной переменной."
    },
    {
      "title": "Что такое AJAX",
      "text": "AJAX (Asynchronous JavaScript and XML) — это технология, которая позволяет добавлять новые данные на страницу без полной перезагрузки страницы. AJAX использует асинхронные запросы для обмена данными между клиентом (браузером) и сервером."
    },
    {
      "title": "Приемы работы с асинхронным кодом.",
      "text": "Приёмы работы с асинхронным кодом в JavaScript включают использование коллбеков, промисов и асинхронных функций. В современном JavaScript на практике используются промисы и асинхронные функции."
    },
    {
      "title": "Что такое promise",
      "text": "Promise – это объект, представляющий результат успешного или неудачного завершения асинхронной операции. Асинхронная операция — это действие, которое выполняется независимо от окружающего кода и не блокирует его выполнение. Промисы могут находиться в трёх состояниях: pending (ожидание), fulfilled (успешное завершение) и rejected (ошибка). Для создания промиса используется конструктор Promise."
    },
    {
      "title": "Какие методы Promise есть",
      "text": "Promise.all(iterable) - Ожидает исполнения всех промисов или отклонения любого из них. Возвращает промис, который исполнится после исполнения всех промисов в iterable. В случае, если любой из промисов будет отклонён, Promise.all будет также отклонён. Promise.allSettled(iterable) - Ожидает завершения всех полученных промисов (как исполнения так и отклонения). Возвращает промис, который исполняется когда все полученные промисы завершены (исполнены или отклонены), содержащий массив результатов исполнения полученных промисов. Promise.race(iterable) - Ожидает исполнения или отклонения любого из полученных промисов. Возвращает промис, который будет исполнен или отклонён с результатом исполнения первого исполненного или отклонённого промиса из iterable. Promise.reject(reason) - Возвращает промис, отклонённый из-за reason. Promise.resolve(value) - Возвращает промис, исполненный с результатом value. "
    },
    {
      "title": "В чём разница между Async/Await и Promise?",
      "text": "Разница между async/await и Promise заключается в том, что async/await является синтаксическим сахаром поверх Promise, обеспечивая более читаемый и синхронный код. Async/await использует ключевое слово async и оператор await для управления асинхронными операциями, упрощая обработку ошибок и делая код более понятным. "
    },
    {
      "title": "Что такое break и continue ",
      "text": "Break – полностью останавливает выполнение цикла. Continue – пропускает итерацию в цикле"
    },
    {
      "title": "Что такое class",
      "text": "Классы в JavaScript — это шаблоны или чертежи, по которым создаются объекты одного типа. Они определяют общие свойства и методы для всех объектов, которые создаются на их основе. Класс содержит конструктор — метод, вызываемый при создании нового объекта и инициализирующий его свойства, а также другие методы (функции), определяющие поведение объекта. "
    },
    {
      "title": "Что такое this",
      "text": "В JavaScript ключевое слово this указывает на текущий контекст выполнения. Его значение зависит от того, как и где используется функция. В глобальном контексте (вне функций) this ссылается на глобальный объект (обычно это объект window в браузерах). В функции значение this зависит от способа вызова функции. Например, простой вызов функции устанавливает значение this на объект глобального контекста, а стрелочные функции связывают this с контекстом выполнения внешней функции. В классах this указывает только на значения в этих же классах."
    },
    {
      "title": "Что такое объект Set",
      "text": "Объект Set — это коллекция уникальных значений, которая концептуально больше похожа на массив, чем на объект. Объекты Set поддерживают порядок вставки элементов и предоставляют методы для работы с элементами, такие как add(), has(), clear() и size."
    },
    {
      "title": "Что такое объект Map",
      "text": "Объект Map — это набор пар «ключ-значение», который может поддерживать порядок записей. В качестве ключей могут использоваться различные типы данных. Объекты Map предоставляют методы для работы с парами «ключ-значение», такие как set(), get(), has() и delete()."
    },
    {
      "title": "WeakMap и WeakSet ",
      "text": "WeakMap и WeakSet — это структуры данных в JavaScript, используемые для хранения пар ключ-значение. Главное отличие от обычных Map и Set заключается в том, что значения в WeakMap и WeakSet могут быть удалены из памяти раньше, чем обычные Map и Set. Это происходит потому, что значения в WeakMap и WeakSet связаны с объектами, которые могут быть удалены из памяти раньше, чем само значение. WeakMap используется для хранения пар ключ-значение, где ключом является объект, а значением — любое другое значение. WeakSet используется для хранения набора уникальных объектов."
    },
    {
      "title": "Как проверить уникальность значений в объекте.",
      "text": "Для этого используется метод Object.values(obj) и объект set() для хранения уникальных значений. "
    },
    {
      "title": "Что такое Рекурсивная функция.",
      "text": "Рекурсивная функция — это числовая функция f(n) числового аргумента, которая в своей записи содержит саму себя."
    },
    {
      "title": "Разница между for…in и for...of",
      "text": "For...in проходит по всем перечисляемым свойствам объекта, включая унаследованные от прототипа. For...of проходит только по значениям элементов объекта, доступным через итератор. Лучше подходит для массивов."
    },
    {
      "title": "Что такое модульное тестирование ",
      "text": "Это процесс проверки отдельных блоков или модулей кода на соответствие ожидаемому поведению. Оно помогает выявить ошибки и убедиться в корректной работе небольших фрагментов кода.Для проведения модульного тестирования в JavaScript можно использовать различные инструменты и библиотеки, например Jest, Mocha и Jasmine."
    },
    {
      "title": "Как использовать регулярные выражения (regex) в JavaScript для обработки текста?",
      "text": "Для использования регулярных выражений в JavaScript, вы можете использовать две основные функции:- search(): возвращает позицию первого совпадения с регулярным выражением в строке. replace(): заменяет часть строки, соответствующую регулярному выражению, на новую строку"
    },
    {
      "title": "Что такое prototype в js",
      "text": "Это объект, от которого другие объекты наследуют его свойства и методы. Каждый объект имеет свой прототип, и если у искомого объекта не хватает каких-либо свойств, они ищутся в прототипе. Через прототип можно создавать свои объекты используя this."
    },
    {
      "title": "Что такое прототипное наследование",
      "text": "Это способ создания объектов без определения классов и наследования. Каждый объект имеет свой прототипный объект, который используется для наследования свойств и методов. При вызове метода или свойства объекта JavaScript ищет свойство в самом объекте и его прототипном объекте."
    },
    {
      "title": "В чём разница между наследованием через прототипы и классическое наследование в JavaScript?",
      "text": "Разница между наследованием через прототипы и классическим наследованием в JavaScript заключается в способе передачи свойств и методов от родительского объекта к дочернему. При наследовании через прототипы свойства и методы родительского объекта хранятся в специальном свойстве прототипа дочернего объекта. Таким образом, изменения в родительском объекте автоматически отражаются на всех дочерних объектах, использующих этот прототип. Классическое наследование, с другой стороны, использует ключевое слово extends для указания родительского класса в объявлении дочернего класса. В этом случае свойства и методы родительского класса копируются в дочерний класс, и изменения должны быть сделаны явно в дочернем классе для обновления поведения."
    },
    {
      "title": "Преобразование объекта в строку",
      "text": "Для преобразования объекта в строку используется JSON.stringify(), а обратно из  JSON строки в объект используется  JSON.parse()."
    },
    {
      "title": "Что такое мемонизация ",
      "text": "Мемоизация — это способ оптимизации, который заключается в сохранении результатов выполнения функций для предотвращения повторных вычислений. Она используется для увеличения скорости работы компьютерных программ. Для мемонизации в реакте используется memo() и useMemo()"
    },
    {
      "title": "Что такое декоратор.",
      "text": "Декоратор в JS — это функция более высокого порядка, которая изменяет поведение функции, метода или класса без изменения их исходного кода. Декораторы используются для добавления дополнительной функциональности к объектам, например, ведения журнала или проверки безопасности."
    },
    {
      "title": "В чём разница между методами addEventListener и attachEvent для регистрации событий в JavaScript? ",
      "text": "Разница между методами addEventListener и attachEvent заключается в том, что addEventListener — это современный и универсальный метод, поддерживаемый всеми современными браузерами, включая IE9 и выше. Он позволяет регистрировать несколько обработчиков событий для одного и того же типа события в одном объекте. AttachEvent — это устаревший метод, поддерживаемый только IE версий 5–8. Он принимает только два аргумента: тип события и функцию обработчика, и не позволяет регистрировать несколько обработчиков для одного события"
    },
    {
      "title": "В чём разница между typeof и instanceof для проверки типа объекта в JavaScript? ",
      "text": "Разница между typeof и instanceof заключается в следующем:  typeof используется для определения типа примитивного значения, такого как число, строка, символ, логическое значение или неопределённое значение. instanceof проверяет, является ли объект экземпляром определённого класса или функции-конструктора. Возвращает true, если объект создан с использованием нового оператора, и false в противном случае. "
    },
    {
      "title": "Как использовать Proxy для контроля доступа к свойствам объектов в JavaScript?",
      "text": "Чтобы использовать Proxy для контроля доступа к свойствам объектов в JavaScript, выполните следующие шаги: Создайте новый объект Proxy с помощью синтаксиса new Proxy(). Определите целевой объект, который будет использоваться внутри Proxy. Создайте объект-обработчик с помощью синтаксиса const handler = { ... }. В объекте-обработчике определите ловушки (get, set, has, apply, construct) для перехвата доступа к свойствам и присвоения значений. Передайте целевой объект и объект-обработчик в конструктор Proxy. Используйте созданный объект Proxy для доступа к свойствам и методам целевого объекта. "
    },
    {
      "title": "Микро и макротаски",
      "text": "Микротаски (микрозадачи) — это отложенные задачи, которые имеют приоритет над макрозадачами. Примеры микротасков: операции с промисами, операции с очередью мутации и операции, связанные с функцией queueMicrotask(). Макрозадачи (макротаски) — это также отложенные задачи, но с меньшим приоритетом по сравнению с микрозадачами. Примеры макрозадач: обработка таймеров, обработка событий пользовательского ввода и выполнение AJAX-запросов. "
    },
    {
      "title": "Hosting ",
      "text": "Hosting в JavaScript — это процесс доступа к переменным до их определения. Это связано с работой компилятора JavaScript и происходит в два прохода. При первом проходе компилятор получает все объявления переменных и идентификаторы, а при втором проходе выполняется код."
    },
    {
      "title": "Что такое область видимости в JavaScript",
      "text": "это зона доступности элементов в коде. Она может быть глобальной или локальной. Глобальная область видимости означает, что элементы программы открыты для использования в любой её части, а локальная ограничивает доступность элементов определённым блоком или функцией. "
    },
    {
      "title": "Что такое заводские функции",
      "text": "это функция, которая создаёт и возвращает объекты с определёнными свойствами и поведением. Она используется для создания объектов более контролируемым и настраиваемым способом, особенно когда нужно создать несколько объектов с одинаковой логикой."
    },
    {
      "title": "Как работает оператор new в js",
      "text": "Оператор new в JavaScript используется для создания нового экземпляра объекта. Он гарантирует, что ключевое слово this внутри функции-конструктора будет ссылаться на новый объект."
    },
    {
      "title": "Что такое цель события или целевой элемент (event.target)?",
      "text": "Простыми словами, event.target — это элемент, в котором происходит событие, или элемент, вызвавший событие."
    },
    {
      "title": "Что такое текущая цель события (event.currentTarget)?",
      "text": "Event.currentTarget — это элемент, к которому прикреплен прослушиватель событий. Например при нажатии на кнопку, получаем элемент в котором лежит эта кнопка"
    },
    {
      "title": "Как проверить, является ли значение ложным?",
      "text": "Следует использовать функцию Boolean или оператор '!!' (двойное отрицание)."
    },
    {
      "title": "Для чего используется директива «use strict»?",
      "text": "«use strict» — это директива ES5, которая заставляет весь наш код или код отдельной функции выполняться в строгом режиме. Строгий режим вводит некоторые ограничения по написанию кода, тем самым позволяя избегать ошибок на ранних этапах."
    },
    {
      "title": " Что такое IIFE?",
      "text": "IIFE или Immediately Invoked Function Expression — это функция, которая вызывается или выполняется сразу же после создания или объявления. Для создания IIFE необходимо обернуть функцию в круглые скобки (оператор группировки), превратив ее в выражение, и затем вызвать ее с помощью еще одних круглых скобок. Это выглядит так: (function(){})()."
    },
    {
      "title": "Для чего используется метод Function.prototype.apply?",
      "text": "Apply используется для привязки определенного объекта к значению this вызываемой функции. Этот метод похож на Function.prototype.call. Единственное отличие состоит в том, что в apply аргументы передаются в виде массива."
    },
    {
      "title": " Для чего используется метод Function.prototype.call?",
      "text": "Call используется для привязки определенного объекта к значению this вызываемой функции. Этот метод похож на Function.prototype.apply. Отличие состоит в том, что в call аргументы передаются через запятую."
    },
    {
      "title": "В чем разница между методами call и apply?",
      "text": "Отличие между call и apply состоит в том, как мы передаем аргументы в вызываемой функции. В apply аргументы передаются в виде массива, в call — через запятую."
    },
    {
      "title": "Для чего используется метод Function.prototype.bind?",
      "text": "Bind возвращает новую функцию, значением this которой является объект, указанный в качестве первого параметра. В отличие от bind, call и apply сразу же вызывают функцию."
    },
    {
      "title": " Что такое функциональное программирование и какие особенности JS позволяют говорить о нем как о функциональном языке программирования? ",
      "text": "Функциональное программирование — это декларативная концепция программирования или образец (паттерн) того, как строятся приложения, как используются функции, содержащие выражения, которые вычисляют значения без изменения аргументов, которые им передаются. Объект Array содержит методы map, filter и reduce, которые являются самыми известными функциями в мире функционального программирования из-за их полезности, а также потому, что они не изменяют массив, что делает эти функции «чистыми». Также в JS имеются замыкание и функции высшего порядка, которые являются характеристиками функционального языка программирования."
    },
    {
      "title": "Метод map",
      "text": "Метод map возвращает новый массив с результатами вызова callback для каждого элемента массива: "
    },
    {
      "title": "Метод filter ",
      "text": "Метод filter создает новый массив со всеми элементами, которые удовлетворяют условию, указанному в callback"
    },
    {
      "title": "Метод reduce ",
      "text": "Метод reduce выполняет callback один раз для каждого элемента массива, за исключением пустот, принимая четыре аргумента: начальное значение (или значение от предыдущего callback), значение текущего элемента, текущий индекс и итерируемый массив"
    },
    {
      "title": "Что такое функции высшего порядка (Higher Order Functions)?",
      "text": "Функция высшего порядка — это функция, возвращающая другую функцию или принимающая другую функцию в качестве аргумента."
    },
    {
      "title": "Почему функции в JS называют объектами первого класса (First-class Objects)?",
      "text": "Функции называют объектами первого класса, потому что они обрабатываются также, как и любое другое значение в JS. Они могут присваиваться переменным, быть свойством объекта (методом), элементом массива, аргументом другой функции, значением, возвращаемым функцией. Единственным отличием функции от любого другого значения в JS является то, что функция может быть выполнена или вызвана."
    },
    {
      "title": "Что такое объект arguments?",
      "text": " Arguments — это коллекция аргументов, передаваемых функции. Это объект, подобный массиву, у него есть свойство length, мы можем получить доступ к определенному значению с помощью arguments[i], но у него отсутствуют методы forEach, reduce, filter и map. Он позволяет узнать количество параметров функции. Преобразовать arguments в массив можно с помощью Array.prototype.slice (Array.prototype.slice.call(arguments)). Запомните: в стрелочных функциях объект arguments не работает. Если приводит к ошибке ReferenceError: arguments is not defined. Эту проблему можно решить с помощью оператора rest: (const four = (...args) => args). Это автоматически поместит все параметры в массив.      "
    },
    {
      "title": " Что такое ECMAScript?",
      "text": "ECMAScript — это спецификация, стандарт скриптовых языков программирования, он является основой JS, поэтому любые изменения ECMAScript отражаются на JS.      "
    },
    {
      "title": "Что такое стрелочные функции (Arrow Functions)?",
      "text": "Стрелочная функция — это относительно новый способ создания функций в JS. Стрелочные функции создаются быстрее и имеют более читаемый синтаксис, чем функциональные выражения. В стрелочных функциях опускается слово «function»: В функциональном выражении мы используем ключевое слово «return» для возврата значения. В стрелочной функции мы этого не делаем, поскольку стрелочные функции неявно возвращают значения при условии, что мы возвращаем одно выражение или значение: Мы также можем передавать параметры стрелочным функциям. Если мы передаем один параметр, его можно не оборачивать в круглые скобки:  У стрелочных функций нет доступа к объекту arguments. Для получения параметров, переданных функции, мы можем использовать оператор rest."
    },
    {
      "title": "Что такое шаблонные литералы (Template Literals)",
      "text": "Шаблонные литералы — относительно новый способ создания строк в JS. Шаблонные литералы создаются с помощью двойных обратных кавычек (``): В шаблонных литералах нам не нужно экранировать одинарные кавычки. В ES6 нам не нужно использовать управляющую последовательность '/n' для перевода строки. В ES6 нам не нужно использовать конкатенацию строк для объединения текста с переменной: мы можем использовать выражение ${expr} для получения значения переменной."
    },
    {
      "title": "Что такое деструктуризация объекта (Object Destructuring)? ",
      "text": "Деструктуризация — относительно новый способ получения (извлечения) значений объекта или массива."
    },
    {
      "title": "Что такое модули (Modules)?",
      "text": "Модули позволяют объединять (использовать) код из разных файлов и избавляют нас от необходимости держать весь код в одном большом файле. До появления модулей в JS существовало две популярные системы модулей для поддержки кода: Используются export и import, раньше использовался require"
    },
    {
      "title": "Что такое функция обратного вызова (Callback Function)?",
      "text": "Функция обратного вызова — это функция, вызов которой отложен на будущее (происходит при некоторых условиях, например, при наступлении события). () => {func()}"
    },
    {
      "title": " В чем разница между spread-оператором и rest-оператором?",
      "text": "Операторы spread и rest имеют одинаковый синтаксис ('...'). Разница состоит в том, что с помощью spread мы передаем или распространяем данные массива на другие данные, а с помощью rest — получаем все параметры функции и помещаем их в массив (или извлекаем часть параметров)."
    },
    {
      "title": "Что такое параметры по умолчанию (Default Parameters)?",
      "text": "Это возможность определения значений во время передачи в функцию"
    },
    {
      "title": "Что такое объектная обертка (Wrapper Objects)?",
      "text": "Примитивы string, number и boolean имеют свойства и методы, несмотря на то, что они не являются объектами. Причина такого поведения заключается в том, что например (let name = 'marko') временно преобразуется в объект. У каждого примитива, кроме null и undefined, есть объект-обертка. Такими объектами являются String, Number, Boolean, Symbol и BigInt."
    },
    {
      "title": "В чем разница между явным и неявным преобразованием или приведением к типу (Implicit and Explicit Coercion)?",
      "text": "Неявное преобразование — это способ приведения значения к другому типу без нашего ведома (участия). Например если к числу прибавить строку, то произойдет конкатинация. boolean при сложении будет равен 0 и 1. При умножении и делении строка будет преобразована в число. В явном же приобразовании сам разработчик решает какой будет тип у переменной"
    },
    {
      "title": "Что такое NaN? Как проверить, является ли значение NaN?",
      "text": "NaN или Not A Number (не число) — это значение, получаемое в результате выполнения числовой операции над нечисловым значением:"
    },
    {
      "title": " Как проверить, что число является четным, без использования деления по модулю или деления с остатком (оператора '%')?",
      "text": "Для решения данной задачи можно использовать оператор '&' (бинарное и). Оператор '&' сравнивает операнды как бинарные значения."
    },
    {
      "title": "Как определить наличие свойства в объекте?",
      "text": "Первый способ состоит в использовании оператора «in»: console.log('prop' in o)  Второй — использовать метод hasOwnProperty: o.hasOwnProperty('prop2')  Третий — индексная нотация массива: o['prop']"
    },
    {
      "title": "В чем разница между методами Object.freeze и Object.seal?",
      "text": "Разница заключается в том, что при использовании метода Object.freeze мы не можем менять или редактировать свойства объекта, а при использовании Object.seal у нас такая возможность имеется."
    },
    {
      "title": " В чем разница между оператором «in» и методом hasOwnProperty?",
      "text": "Отличие состоит в том, что оператор «in» проверяет наличие свойства не только в самом объекте, но и в его прототипах, а метод hasOwnProperty — только в объекте."
    },
    {
      "title": "Какие приемы работы с асинхронным кодом в JS Вы знаете?",
      "text": "Функции обратного вызова (Callbacks). Промисы (Promises). Async/await. Библиотеки вроде async.js, blueprint, q, co."
    },
    {
      "title": "В чем разница между обычной функцией и функциональным выражением?",
      "text": "В том, что обычную функцию можно вызвать когда угодно благодаря всплытию"
    },
    {
      "title": "Почему typeof null возвращает object? Как проверить, является ли значение null?",
      "text": "typeof null == 'object' всегда будет возвращать true по историческим причинам. Поступало предложение исправить эту ошибку, изменив typeof null = 'object' на typeof null = 'null', но оно было отклонено в интересах сохранения обратной совместимости (такое изменение повлекло бы за собой большое количество ошибок)."
    },
    {
      "title": "Что такое параметры по умолчанию (Default Parameters)?",
      "text": "Это возможность определения значений во время передачи в функцию"
    },
    {
      "title": "Что такое параметры по умолчанию (Default Parameters)?",
      "text": "Это возможность определения значений во время передачи в функцию"
    },
    {
      "title": "Event loop",
      "text": "Event Loop - это специальный механизм на уровне движка js, который координирует работу трёх сущностей: Call Stack (стэк вызовов), Web API (API, предоставляемый браузером), Callback Queue (очередь колбэков). Работают они следующим образом: движок js анализирует код. Когда он встречает вызов какой-то функции, он перемещает эту функцию в Call Stack. Если эта функция синхронная (например, console.log()), то она сразу же исполняется, покидает стэк и на её место приходит следующая функция. Если же эта функция асинхронная, например, setTimeout(), обработчик событий, сетевой запрос и т.д., то на помощь приходит браузер со своим Web API (мы же помним, что JavaScript - это однопоточный язык, и сам работать в многопоточном режиме он не может). Event Loop перемещает колбэк асинхронной функции в Web API, а сама асинхронная функция уходит из стэка вызовов. То есть, пока колбэк асинхронной функции находится под управлением Web API, движок js продолжает выполнять другие операции!  Что же происходит с колбэком? В случае, например, setTimeout(), Web API ожидает истечения указанного времени, затем Event Loop перемещает этот колбэк в Callback Queue (очередь колбэков). Когда стэк вызовов освобождается, Event Loop перемещает в него наш колбэк из очереди колбэков, после чего колбэк наконец исполняется и покидает стэк вызовов. Этот процесс повторяется до тех пор, пока весь js код не будет выполнен."
    }
  ],
  "ts": [
    {
      "title": "Что такое дженерики",
      "text": "Дженерики в TypeScript — это механизм, позволяющий писать универсальный код, который может работать с данными разных типов. Они помогают избегать использования типа any и обеспечивают безопасность типов. Для этого в функцию или метод добавляется параметр типа, через который передаётся нужный тип. Таким образом, код становится гибким и переиспользуемым, что облегчает разработку и поддержку больших проектов."
    },
    {
      "title": "Поддерживает ли ts ООП",
      "text": "Да поддерживает. Инкапсуляцию, полиморфизм, абстракцию, наследование."
    },
    {
      "title": "При каких случаях выдается false",
      "text": "Null, undefined, NaN, Пустая строка, 0, false"
    },
    {
      "title": "Как реализовать константу в классе в TS",
      "text": "Для этого используется модификатор readonly"
    },
    {
      "title": "Что представляют собой .map-файлы в TypeScript?",
      "text": "Файлы с расширением .map хранят карты кода (source map), которые содержат данные о соответствии кода, написанного на TypeScript, JavaScript-коду, созданному на его основе. С этим файлами могут работать многие отладчики (например — Visual Studio и инструменты разработчика Chrome). Это позволяет, в ходе отладки, работать с исходным кодом программ на TypeScript, а не с их JS-эквивалентами."
    },
    {
      "title": "Что такое геттеры и сеттеры в TypeScript?",
      "text": "TypeScript поддерживает геттеры и сеттеры, которые позволяют управлять доступом к членам объектов. Они дают разработчику средства контроля над чтением и записью свойств объектов. Set используется для записи, а Get для получения."
    },
    {
      "title": "Расскажите об основных компонентах TypeScript.",
      "text": "Язык. Это, с точки зрения разработчиков, самая важная часть TypeScript. «Язык» — это синтаксис, ключевые слова, всё то, что позволяет писать программы на TypeScript.Компилятор. TypeScript обладает компилятором с открытым исходным кодом, он является кросс-платформенным, с открытой спецификацией, и написан на TypeScript. Компилятор выполняет преобразование TypeScript-кода в JavaScript-код. Кроме того, если с программой что-то не так, он выдаёт сообщения об ошибках. Он позволяет объединять несколько TypeScript-файлов в один выходной JS-файл и умеет создавать карты кода. Вспомогательные инструменты. Вспомогательные инструменты TypeScript предназначены для облегчения процесса разработки с его использованием в различных IDE. Среди них — Visual Studio, VS Code, Sublime, различные средства для быстрого запуска TS-кода, и другие."
    },
    {
      "title": "Расскажите об использовании декораторов свойств в TypeScript. ",
      "text": "Декораторы работают так-же как и в JS, только присваиваются они теперь через символ @admin "
    },
    {
      "title": "Можно ли в TypeScript использовать строго типизированные функции в качестве параметров?",
      "text": "Да, можно. "
    },
    {
      "title": "Как сделать так, чтобы классы, объявленные в модуле, были бы доступны и за пределами этого модуля? .",
      "text": "Для того чтобы сделать класс, объявленный в модуле, доступным за пределами этого модуля, нужно воспользоваться ключевым словом export:"
    },
    {
      "title": "Поддерживает ли TypeScript перегрузку функций?",
      "text": "TypeScript поддерживает перегрузку функций, но реализация этого механизма отличается от той, которую можно видеть в других объектно-ориентированных языках. А именно, в TS создают лишь одну функцию и некоторое количество объявлений. Когда такой код компилируется в JavaScript, видимой оказывается лишь одна конкретная функция. Этот механизм работает из-за того, что JS-функции можно вызывать, передавая им разное количество параметров."
    },
    {
      "title": "Как в TypeScript перегрузить конструктор класса?",
      "text": "TypeScript позволяет объявлять множество вариантов методов, но реализация может быть лишь одна, и эта реализация должна иметь сигнатуру, совместимую со всеми вариантами перегруженных методов. Для перегрузки конструктора класса можно воспользоваться несколькими подходами i. Можно воспользоваться необязательным параметром: ii. Можно воспользоваться параметрами по умолчанию: iii. Можно использовать дополнительные перегрузки в виде методов статической фабрикиiv. Можно использовать тип-объединение"
    },
    {
      "title": "Чем различаются ключевые слова interface и type в TypeScript?",
      "text": "В отличие от объявления интерфейса, которое всегда представляет именованный тип объекта, применение ключевого слова type позволяет задать псевдоним для любой разновидности типа, включая примитивные типы, типы-объединения и типы-пересечения. При использовании ключевого слова type вместо ключевого слова interface теряются следующие возможности:  Интерфейс может быть использован в выражении extends или implements, а псевдоним для литерала объектного типа  нет. Интерфейс может иметь несколько объединённых объявлений, а при использовании ключевого слова type эта возможность не доступна."
    },
    {
      "title": "Расскажите о том, когда в TypeScript используют ключевое слово declare.",
      "text": "Ключевое слово declare используется в TypeScript для объявления переменных, источником которых может служить некий файл, не являющийся TypeScript-файлом. Например, представим, что у нас имеется библиотека, которая называется myLibrary. У неё нет файла с объявлениями типов TypeScript, у неё имеется лишь пространство имён myLibrary в глобальном пространстве имён. TypeScript назначит переменной myLibrary тип any. Проблема тут заключается в том, что у вас не будет, во время разработки, интеллектуальных подсказок по этой библиотеке, хотя использовать её в своём коде вы сможете."
    },
    {
      "title": "Что такое внешние объявления переменных в TypeScript и когда их нужно использовать?",
      "text": "Внешнее объявление переменной (ambient declaration) — это механизм, который позволяет сообщать компилятору TypeScript о том, что некий исходный код существует где-то за пределами текущего файла. Внешние объявления помогают интегрировать в TS-программы сторонние JavaScript-библиотеки. Эти объявления делают в файле объявления типов с расширением .d.ts. Внешние переменные или модули объявляют так: declare module Module_Name {} Файлы, в которых находится внешний код, должны быть подключены в TS-файле, использующем их, так: /// <reference path=' Sample.d.ts'></reference>"
    },
    {
      "title": "Можно ли автоматически генерировать файлы объявлений TypeScript из JS-библиотек?",
      "text": "JavaScript не всегда содержит достаточно информации, которая позволяет TypeScript автоматически выводить типы. Поэтому практически невозможно автоматически создавать объявления типов, основанные на JavaScript. Однако можно попытаться это сделать, воспользовавшись следующими инструментами:  Microsoft/dts-gen — официальное средство, используемое Microsoft как отправная точка при создании объявлений типов. dtsmake — многообещающий инструмент для автоматического создания объявлений типов на основе JS-файлов, находящийся в процессе разработки. Он зависит от системы анализа кода Tern, которую используют некоторые редакторы для реализации механизма автозавершения при вводе JS-кода."
    },
    {
      "title": "Можно ли автоматически генерировать файлы объявлений TypeScript из JS-библиотек?",
      "text": "JavaScript не всегда содержит достаточно информации, которая позволяет TypeScript автоматически выводить типы. Поэтому практически невозможно автоматически создавать объявления типов, основанные на JavaScript. Однако можно попытаться это сделать, воспользовавшись следующими инструментами: Microsoft/dts-gen — официальное средство, используемое Microsoft как отправная точка при создании объявлений типов. dtsmake — многообещающий инструмент для автоматического создания объявлений типов на основе JS-файлов, находящийся в процессе разработки. Он зависит от системы анализа кода Tern, которую используют некоторые редакторы для реализации механизма автозавершения при вводе JS-кода."
    },
    {
      "title": "Какие есть способы задать тип значения равным классу, внутри которого тип задаётся без использования его имени",
      "text": "Можно с помощью this, хотя лучше писать с использованием имени явно."
    },
    {
      "title": "Какие есть способы задать тип значения, обозначающих конкретный декорируемый конкретным декоратор класс?",
      "text": "Нет таких способов. И в целом, я думаю, что использовать декораторы, как множественное наследование — bad practice. Если нужно добавить в класс функциональность с публичным интерфейсом, лучше сделать это явно, без магии. А декораторы как раз предназначены для того, чтобы изменить поведение класса, не меняя интерфейс."
    },
    {
      "title": "Как присвоить один интерфейс другому",
      "text": "Можно с помощью extends, а вырезать при присваивании определенные элементы можно использовав Omit<interface, ...'params'>"
    },
    {
      "title": "Как реализовать интерфейс для класса",
      "text": "для этого испольузется ключевое слово - implements"
    },
    {
      "title": "Кортежи",
      "text": "Кортежи (Tuples) также, как и массивы, представляют набор элементов, для которых уже заранее известен тип. В отличие от массивов кортежи могут хранить значения разных типов. Для определения кортежа применяется синтаксис массива: // определение кортежа - кортеж состоит из двух элементов - строки и числа let user: [string, number]; В данном случае кортеж user представляет тип [string, number], то есть такой кортеж, который состоит из двух элементов, при чем первый элемент представляет тип string, а второй элемент - тип number. Для присвоения значения применяется массив: user = ['Tom', 28]; Причем передаваемые кортежу данные должны соответствовать элементам по типу."
    },
    {
      "title": "Как реализовать интерфейс для класса",
      "text": "для этого испольузется ключевое слово - implements"
    },
    {
      "title": "Как реализовать интерфейс для класса",
      "text": "для этого испольузется ключевое слово - implements"
    }
  ],
  "react": [
    {
      "title": "Что такое React JS?",
      "text": "React JS, или просто React, это открытая библиотека JavaScript для создания пользовательских интерфейсов, особенно для одностраничных приложений (SPA). Ключевые особенности React:\n1) Компонентный подход: React строится на концепции компонентов, что позволяет разработчикам создавать легко переиспользуемые куски кода;\n2) Виртуальный DOM: React использует виртуальный DOM для отслеживания изменений. Это абстракция реального DOM, что позволяет библиотеке обновлять только те части интерфейса, которые действительно изменились, вместо полного перерендеринга страницы. Это делает React относительно быстрым;\n3) Хуки: Введение хуков позволило использовать состояния и другие возможности классовых компонентов в функциональных компонентах, что сделало код более кратким и чистым;\n4) Сообщество и экосистема: React имеет большое и активное сообщество разработчиков, а также много библиотек и инструментов, созданных сообществом, что облегчает разработку сложных приложений.\n\nПодробнее: <a href='https://youtu.be/R_39q-vdOaE?si=mEKDaYDjEdnojG-N' target='_blank'>Введение в React (видео)</a>"
    },
    {
      "title": "Для чего нужен атрибут key при рендере списков?",
      "text": "Ключи (keys) помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени. Лучший способ выбрать ключ — это использовать строку, которая будет явно отличать элемент списка от его соседей. Лучше всего вы будете использоваташих данных как ключи. Индексы массива тоже можно использовать для этого, но только если элементы массива не добавляются в начало, не переставляются и не удаляются."
    },
    {
      "title": "Как работает проп children?",
      "text": "Некоторые компоненты не знают своих потомков заранее. Это особенно характерно для таких компонентов, как Sidebar или Dialog, которые представляют из себя как бы «коробку», в которую можно что-то положить. Для таких компонентов можно использовать специальный проп children, который передаст дочерние элементы сразу на вывод.\n\nПодробнее: <a href='https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children' target='_blank'>Документация React (eng)</a>"
    },
    {
      "title": "Что такое порталы в React?",
      "text": "Порталы позволяют рендерить дочерние элементы в DOM-узел, который находится вне DOM-иерархии родительского компонента. Типовой случай применения порталов — когда в родительском компоненте заданы стили overflow: hidden или z-index, но вам нужно, чтобы дочерний элемент визуально выходил за рамки своего контейнера. Чаще всего, это диалоговые окна, всплывающие карточки и всплывающие подсказки."
    },
    {
      "title": "Что такое Reconciliation (Cверка)?",
      "text": "Это процесс, посредством которого React обновляет DOM. Когда состояние компонента изменяется, React должен рассчитать необходимость обновления DOM. Это делается путем создания виртуального DOM и сравнения его с текущим DOM. В этом контексте виртуальный DOM будет содержать новое состояние компонента."
    },
    {
      "title": "Для чего используется хук useEffect в React?",
      "text": "Хук useEffect используется для выполнения побочных эффектов из функционального компонента"
    },
    {
      "title": "Что будет, если вторым аргументом в useEffect передать пустой массив []?",
      "text": "Если передать вторым аргументов пустой массив, тогда useEffect будет запущен 1 раз"
    },
    {
      "title": "Какой хук используется для создания состояния в компоненте?",
      "text": "Для создания состояния используется хук - useState"
    },
    {
      "title": "Какой элемент используется для группировки элементов без добавления дополнительных узлов в DOM?",
      "text": "Для группировки элементов без добаления дополнительных тегов используется <Fragment> (<>)"
    },
    {
      "title": "У нас есть массив со строками (arr), каждую из которых мы хотим отразить на странице. Какой метод массива нужно применить в return компонента?",
      "text": "Для обработки массива используется метод {arr.map(...)}"
    },
    {
      "title": "Какой элемент используется для обработки ошибок в дереве компонентов?",
      "text": "Для обработки ошибов в дереве компонентов используется элемент - ErrorBoundary"
    },
    {
      "title": "Какой (какие) аргумент(ы) принимает хук useMemo?",
      "text": "useMemo принимает такие аргументы как функцию и массив зависимостей"
    },
    {
      "title": "Для чего используется хук useCallback в React?",
      "text": "useCallback используется для Мемоизации функций"
    }
  ],
  "restApiHttp": [
    {
      "title": "Что такое протокол передачи данных? Протокол HTTP - Hyper Text Transfer Protocol",
      "text": "Протокол передачи данных - это набор соглашений, которые определяют обмен данными между различными программами. Эти соглашения задают единообразный способ передачи сообщений и обработки ошибок."
    },
    {
      "title": "Как работает HTTP",
      "text": "Когда мы вводим в браузере поисковой запрос или url, на сервер отправляется GET запрос на указанный сервер. \n Например если это поиск Яндекс, то отправка идет на сервер этого поиска. Затем сервер после получения запроса, отвечает браузеру HTTP-ответом, который содержит HTML и уже после получения, браузер отображает HTML-код на экране в виде страницы.  \n  Так же если необходимо отправить данные при заполнении какой нибудь формы, то отправляется POST запрос. "
    },
    {
      "title": "Что такое API",
      "text": "API - является своего рода интерфейсом, набором функций. Который позволяет системе ответить, какие операции она выполняет. API включает в себя саму операцию, необходиму для выполнения, данные на входе и данные на выходе. \n API можно группировать по функционалу, а можно не группировать и сделать одно общее. \n Вызвать API можно как напрямую, так и косвенно: \n Напрямую:  \n 1. Система вызывает функции внутри себя. \n 2. Система вызывет метод другой системы. \n 3. Пользователь вызывает метод. \n 4. Автотесты дергают метод. \n Косвенно: \n 1. Пользователь работает с GUI."
    },
    {
      "title": "Какие выды общения API бывают?",
      "text": "Remote API - когда происходит общение по сети (HTTP и т.д) \n Local API - когда программа общается сама с собой или другими программами в одной вируальной памяти."
    },
    {
      "title": "Что такое REST",
      "text": "REST означает REpresentational State Transfer (передача репрезантативного состояния). Это набор согласованных правил и ограничений, для написания серверного приложения, для того, что бы все системы легко обменивались данными и приложение было легкомаштабируемым. "
    },
    {
      "title": "Какие ограничения выполняются?",
      "text": "В данном подходе все ограничения должны обязательно выполняться кроме (кода по требованию). Если кроме него не выполняются еще ограничения, то это уже не REST подход. "
    },
    {
      "title": "Является ли REST протоколом передачи данных?",
      "text": "REST не является протоколом передачи данных, это скорее всего парадигма. Он не определяет правила о том, как передавать запросы, их структуру и возвращение ошибок. Единственно необходимо содержать информацию, можно ли получанный ответ кешировать."
    },
    {
      "title": "REST - HTTP одно и тоже?",
      "text": "REST не является HTTP, но они очень тесно взаимносвязаны."
    },
    {
      "title": "Сколько принципов (ограничений) содержит REST?",
      "text": "REST содержит шесть принципов \n 1. Клиент-серверная архитектура. \n 2. Stateless. \n 3. Кеширование. \n 4. Единообразие интерфейса. HATEOAS \n 5. Layered system \n 6. Code on done (optional)"
    },
    {
      "title": "Клиент-серверная архитектура.",
      "text": "Клиент-серверная архитектура позволяет хранить все данные на сервере: \n 1. У данной архитектуры есть маштабируемость. Можно использовать не один сервер, и подключить достаточно большое количество клиентов. \n 2. Так-же все изменения будут происходит на сервере. \n 3. Но есть и минусы, если отказал сервер, и нет дополнительных инстансов, то это означает неработоспособность системы. Так-же может увеличиться нагрузка на сервер."
    },
    {
      "title": "Stateless",
      "text": " Stateless - принцип, который заключается в том, что сервер не должен хранить у себя информацию о сессии с клиентом. Он должен в каждом запросе получать всю информацию для обработки в отличии от принципа Stateful. \n 1. Данный принцип позволяет маштабировать сервер, уменьшить время обработки запроса, он понятен и прост, так-же есть возможность использования кеширования."
    },
    {
      "title": "Кеширование",
      "text": "Кеширование - при первом обращении сервер перед отправкой клиенту ответа, сохраняет полученную информацию в кеш. Для того, что бы при повторном запросе, сервер не обращался к базе, а просто взял сохраненные данные и отправил их клиенту. Что уменьшает нагрузку на сервер и ускоряет получение данных."
    },
    {
      "title": "HATEOAS Единообразие интерфейса.",
      "text": "Ограничение REST, согласно которому сервер возвращает не только ресурс, но и его связи с другими ресурсами и действия, которые можно с ним совершить. Получая такие ответы, клиент сам решает как распоряжаться полученной информацией. Что дает гибкость в плане изменений на сервере с точки зрения допустимых действий. Однако это дает сильное усложнение логики клиента, что может повлиять на логику сервера, потому что такие ответы нужно правильно формировать."
    },
    {
      "title": "Layered system (слоистая архитектура)",
      "text": "Layered system (слоистая архитектура) - Концепция слоистой архитектуры. \n Заключается в том, что ни клиент, ни сервер, не должны знать о том, как происходит цепочка вызовов дальше своих прямых соседей. Например, если идет балансировщик, за ним proxy, а спереди уже сервер. То, то что было раньше proxy, балансировщику не известно.\n Если изменяется поведение proxy-сервера, то это не должно повлечь изменения для клиентского приложения или сервера.\n Однако с таким подходом увеличивается нагрузка на сеть, что способствует увеличению времени получения ответа."
    },
    {
      "title": "Code on done (Код по требованию)",
      "text": "Позволяет внести изменения на сервере, например цвет объекта при клике на него с помощью кода, а затем передать клиенту результат."
    }
  ],
  "cors": [
    {
      "title": "Что такое CORS",
      "text": "Это механизм, который позволяет выполняемым скриптам в браузере взаимодействовать с ресурсами, имеющими разный origin, а именно разные ссылки, по сравнению с ссылкой, где выполняется изначальный запрос."
    },
    {
      "title": "На какие виды ресурсов реагирует CORS?",
      "text": "Разный домен (vk.com и ok.ru), Разный протокол (http и https), Разный порт (3000 и 3001)"
    },
    {
      "title": "Как реагирует CORS?",
      "text": "Если передать запрос со своего сайта на тот, где cors не был настроен. То выдасть ошибку - (Access-Control-Allow-Origin), которая говорит о не правильном заголовке и не пропустит запрос."
    },
    {
      "title": "Что было до CORS?",
      "text": " До механизма CORS было невозможно совершить запрос между разными доменами, так как это было связано с безопасностью."
    },
    {
      "title": "Как настроить CORS? - 1",
      "text": "Для этого необходимо на стороне бэкенда конфигурировать такие заголовки, как  * Access-Control-Allow-Origin - который позволяет указать те домены, с которых можно высылать запрос. { * - все домены, что не безопасно. * - или же указать свои.}"
    },
    {
      "title": "Как настроить CORS? - 2",
      "text": "* Access-Control-Allow-Credentials - который позволяет при значении 'true' использовать куки при аутентификации."
    },
    {
      "title": "Как настроить CORS? - 3",
      "text": "* Access-Control-Allow-Methods - указывает, каким http-методам дозволено совершить запрос. GET, POST, PUT, DELETE."
    },
    {
      "title": "На какие типы запрсов делится CORS?",
      "text": "CORS делит запросы на 2 типы: простые и preflight"
    },
    {
      "title": "Простые запросы CORS",
      "text": "Простые запросы. * Методы GET, POST, или HEAD * При использовании заголовка Content-Type должны быть такие значения: application/x-www-[form-urlencoded] или multipart/form-data или text/plain"
    },
    {
      "title": "Все остальные запросы CORS будут являться Preflight.",
      "text": "Если запрос не является простым, то браузер автоматически пошлет preflight запрос с методом OPTION, цель которого разузнать возможности CORS-сервера, куда идет запрос и если сервер вернет заголовки, то браузер пошлет еще запрос за данными, которые требуются."
    }
  ]
}
